---
layout: post
title: Array
category: Data Structure
tag: Machine Learning
---



본 게시물은 [카이스트 문일철 교수님의 강의](https://www.edwith.org/datastructure-2019s/lecture/40291/) 를 참조하여 작성하였습니다.



# 배열 (Array)

배열(Array)은 기본적으로 동일한 데이터끼리 **인덱스를 활용하여 저장, 접근** 할 수 있는 자료형이다. 때문에 배열의 각 요소에는 0부터 순차적으로 증가하는 인덱스가 할당되어 있다. 파이썬의 경우 좀 더 배열을 좀 더 일반적으로 만든 리스트(List)라는 자료형을 사용한다. 다른 언어는 배열에 들어가는 자료의 종류와 배열의 크기를 미리 정해주어야 하지만 파이썬은 좀 더 간단하게 리스트를 만들 수 있다.



```python
x = ['a', 'b', 'd', 'e', 'f']
```



## 배열 탐색하기

특정 요소가 배열 안에 있는 지를 탐색하는 기본적인 알고리즘을 생각해보자. (파이썬에서는 in 함수를 사용할 수 있지만 좀 더 일반적인 경우를 가정) 위에서 말했듯 배열에는 인덱스가 있기 때문에 이를 활용하여 각각의 요소를 살펴볼 수 있다. 위에서 등장한 `x` 에서 반복문을 통해 `'c'` 와 `'d'` 를 찾는다고 하자. `'c'` 를 탐색할 경우처럼 배열 내에 요소가 없을 때는 요소의 개수(N)만큼 검색을 하게 되고, `'d' `를 탐색할 경우처럼 배열 내에 요소가 있을 경우 그 인덱스까지만(최대 N회) 검색을 하게된다.



## 삽입

`'c' `가 없다는 것을 알고 배열 속(인덱스 2)에 삽입할 경우를 생각해보자. 삽입은 탐색보다 복잡한 과정을 거친다. (1) 먼저 원래의 배열보다 하나 더 큰 리스트를 만든다(이 리스트를 `y` 라고 하자). (2) 두 번째로 삽입할 인덱스 이전까지의 reference를 `x` 에서 `y` 로 복사한다. (3) 세 번째로는 삽입할 인덱스에서 하나의 reference를 삽입할 값, `'c'` 에 연결한다. (4) 그리고 `x` 의 나머지 부분에 해당하는 reference를 `y` 의 인덱스를 하나씩 증가한 부분에 복사한다. (5) 마지막으로 `x` 의 reference를 모두 `y` 의 reference로 변경하면 삽입 과정이 완료된다. 이를 코드로 나타내면 아래와 같다.

```python
x = ['a', 'b', 'd', 'e', 'f']
idxInsert = 2
valInsert = 'c'

y = list(range(6))

for itr in range(0, idxInsert):
    y[itr] = x[itr]
    
y[idxInsert] = valInsert

for itr in range(idxInsert, len(x)):
    y[itr+1] = x[itr]
    
x = y
```

삽입할 인덱스 `idxInsert` 를 `a` 라 나타내었을 때, 위와 같은 삽입 과정을 진행할 때는 (2)에서 a 만큼의 Operation이 소요된다. (3)에서 1번의 Operation이 필요하며, (4)에서는 (N-a-1)만큼의 Operation이 필요하게 된다. 때문에 삽입 과정에 필요한 총 Operation의 횟수는 a+1+(N-a-1) = N이 된다.



## 삭제

배열에서 요소를 삭제하는 과정은 삽입 과정과 유사하다. (1) 먼저 인덱스가 하나 적은 배열을 만든다. (2) 그리고 삭제하려는 인덱스 이전에 있는 레퍼런스는 새로운 배열에 그대로 복사한다. (3) 삭제하려는 요소는 그대로 건너뛴다. (4) 이후 요소들에 연결된 레퍼런스는 새로운 배열에 인덱스를 하나씩 감소시켜 복사한다. (5) 마지막으로 원래 배열의 reference를 새로운 배열의 reference로 변경하면 삭제 과정이 완료된다. 원래의 배열 `x` 에서 `'d'` 를 삭제하는 과정은 다음과 같다.

```python
x = ['a', 'b', 'c', 'd', 'e', 'f']
idxDelete = 3

y = list(range(5))

for itr in range(0, idxDelete):
    y[itr] = x[itr]
    
for itr in range(idxDelete+1, len(x)):
    y[itr-1] = x[itr]
    
x = y
```

삭제할 요소의 인덱스 `idxDelete` 를 `a` 라 나타내었을 때, 위와 같은 삭제 과정을 진행할 때는 (2)에서 a 만큼의 Operation이 소요된다. (4)에서는 (N-a-1)만큼의 Operation이 필요하게 된다. 때문에 삭제 과정에 필요한 총 Operation의 횟수는 a+(N-a-1) = N-1이 된다.



## 문제점

위에서 본 것처럼 배열 속 요소를 탐색하거나 새로운 요소를 삽입, 기존 요소를 삭제하는 절차를 위해서는 최대 N번의 Operation이 필요하다. 배열 내에 수 개의 요소만 있을 경우에는 크게 상관이 없지만 N이 매우 커져 1,000,000개의 요소가 있는 배열이 있다면 하나를 삽입하거나, 삭제하는 데에만도 꽤 오랜 시간이 걸릴 것이다.

삽입을 하는 경우 일정 요소들을 뒤로 이동시키지 않고도 공간을 자동으로 만들어 주는 방법이 있다면 어떨까? 이런 방법은 선형 구조인 배열(Array)에서는 절대 불가능할 것이다. 선형이 아닌 공간에서 이런 방법을 가능케 하는 새로운 데이터 핸들링 방식이 있는데 이를 Linked List라고 한다.