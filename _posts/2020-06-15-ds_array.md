---
layout: post
title: 배열 (Array)
category: Data Structure
tag: Data Structure
---



본 게시물은 [카이스트 문일철 교수님의 강의](https://www.edwith.org/datastructure-2019s/lecture/40291/) 를 참조하여 작성하였습니다.



# 배열 (Array)

**배열(Array)** 이란 기본적으로 동일한 자료형의 데이터를 인덱스를 활용하여 저장 및 접근할 수 있는 자료형입니다. 그렇기 때문에 배열의 각 요소에는 0부터 순차적으로 증가하는 인덱스가 할당되어 있습니다.

파이썬에서는 배열을 좀 더 일반화한 리스트(List)라는 자료형을 사용합니다. C, C++ 등의 언어는 배열에 들어가는 자료형의 종류와 배열의 크기를 미리 정해주어야 하지만 파이썬의 리스트는 이를 미리 지정하지 않고 리스트를 생성할 수 있습니다. 또한 리스트에서는 여러 자료형이 하나의 리스트에 들어가도록 할 수 있습니다.

```python
x = ['a', 'b', 'd', 'e', 'f']
```



## 배열에서의 탐색(Search)

배열 안에 특정 요소가 있는 지를 탐색하는 알고리즘을 설계해 봅시다. 정렬된 배열의 경우 다른 알고리즘을 적용할 수도 있지만, 일반적인 경우는 0번째 인덱스부터 순차적으로 접근하여 그 값이 찾고자 하는 값인지 아닌 지를 비교합니다. 이를 **선형 탐색(Linear search)** 알고리즘이라고 합니다. 아래는 배열에서 선형 탐색 알고리즘이 이루어지는 과정을 도식화하여 나타낸 것입니다.

<img src="https://user-images.githubusercontent.com/45377884/89652554-95857400-d900-11ea-9e8a-30b1f50cc9ec.png" alt="array1" style="zoom:67%;" />

위에서 등장한 배열 `x` 에서 선형 탐색 알고리즘을 통해 `'c'` 와 `'d'` 를 찾는 과정을 생각해봅시다. 먼저 `'c'` 를 찾는 과정입니다. 우리는 `'c'` 가 없다는 것을 한눈에 알 수 있지만 컴퓨터는 한 번에 하나의 요소밖에 보지 못하므로 순차적으로 매 인덱스에 위치한 요소값을 확인하여 비교하여야 합니다. 알고리즘은 `True` 가 나올 때까지 진행되므로 

위에서 등장한 `x` 에서 반복문을 통해 `'c'` 와 `'d'` 를 찾는다고 하자. `'c'` 를 탐색할 경우처럼 배열 내에 요소가 없을 때는 요소의 개수(N)만큼 검색을 하게 되고, `'d' `를 탐색할 경우처럼 배열 내에 요소가 있을 경우 그 인덱스까지만(최대 N회) 검색을 하게된다.



## 배열에서의 삽입(Insert)

이번에는 삽입 알고리즘 과정에 대해 생각해봅시다. 만약 위 배열 `'b'` 와 `'d'` 사이에 `'c'` 를 삽입하는 작업은 어떻게 할 수 있을까요?  배열에 특정 요소를 삽입할 때 원천적으로 발생하는 문제가 하나 있습니다. 위에서 배열은 크기가 정해져 있다고 했는데 어떻게 이미 만들어진 배열 안에 하나의 요소를 더 넣을 수 있을까요? 정담은 없습니다. 운전자 1명과 손님 4명이 타고 있는 택시에 손님을 태울 수 없는 것과 마찬가지입니다. 5명이 하나의 택시를 타려면 소형차가 아닌 중형보다 큰 새로운 차를  필요로 하는 것처럼, 배열도 정해진 개수보다 많은 요소를 삽입하려면 새로운 배열이 필요합니다.

우리의 목표는 하나의 요소를 삽입하는 것이므로 가장 먼저 원래의 배열보다 하나 더 큰 빈 배열을 만듭니다. 두 번째로는 새로운 요소를 삽입할 인덱스 이전까지의 참조(Reference)를 원래의 배열 `x` 에서 새로운 배열 `y` 로 복사합니다. 새로 삽입할 요소의 인덱스가 되면 그 참조를 우리가 삽입하고자 하는 값, 즉  `'c'` 에 연결합니다. 다시 다음 인덱스부터는 원래 배열 `x` 의 참조를 새로 만드는 배열의 하나씩 증가한 인덱스 `y` 에 복사합니다. 마지막으로 `x` 의 참조를 `y` 의 참조로 변경하면 삽입 과정이 완료됩니다. 아래는 이 과정을 도식화하여 나타낸 것입니다.

<img src="https://user-images.githubusercontent.com/45377884/89652559-96b6a100-d900-11ea-994c-eabeb330c5b9.png" alt="array2" style="zoom:67%;" />

이 과정을 파이썬 코드로 구현하면 아래와 같습니다.

```python
x = ['a', 'b', 'd', 'e', 'f']
idxInsert = 2
valInsert = 'c'

y = list(range(6))

for itr in range(0, idxInsert):
    y[itr] = x[itr]
    
y[idxInsert] = valInsert

for itr in range(idxInsert, len(x)):
    y[itr+1] = x[itr]
    
x = y
```

삽입 알고리즘에서는 Operation이 몇 번이나 일어날까요? 단계를 나누어 생각해봅시다. 원래 배열의 크기를 N, 새로운 요소를 삽입할 인덱스  `idxInsert`  를 `a` 라고 합시다. 그렇다면 그 `0` 부터 `a-1` 까지 참조를 복사하는 데 $a$ 번의 Operation을 수행합니다. 인덱스 `a` 에서 원하는 요소와 참조를 연결하는 과정에서는 $1$ 번의 Operation을 수행합니다. 인덱스 `a+1` 부터 `N` 까지의 참조를 복사하는 데에는 $N - a$ 번의 Operation을 수행합니다. 세 과정에서 수행하는 Operation의 개수를 합하면 삽입 알고리즘에 필요한 총 Operation 횟수가 $N + 1 = a + 1 + (N - a)$ 임을 알 수 있습니다.



## 배열에서의 삭제(Delete)

배열에서 특정 요소를 삭제하는 과정은 삽입 과정과 유사합니다. 배열에서 `'d'` 를 삭제하는 작업에 대해 생각해봅시다. 배열에는 빈자리도 있을 수 없으므로 하나의 요소를 삭제하기 위해서는 먼저 인덱스가 하나 적은 배열을 만들어야 합니다. 이후에는 삭제하려는 인덱스 이전에 있는 참조를 새로운 배열에 그대로 복사합니다. 삭제하려는 인덱스 이전에 있는 참조는 건너뛰게 되며 해당 인덱스 이후부터는 다시 새로운 배열의 하나씩 감소시킨 인덱스에 참조를 복사합니다. 마지막으로 원래의 배열 `x` 의 참조를 새로운 배열의 참조로 변경하면 삭제 과정이 완료됩니다.

<img src="https://user-images.githubusercontent.com/45377884/89652560-974f3780-d900-11ea-9836-0d8c3cb6bace.png" alt="array3" style="zoom:67%;" />

이 과정을 파이썬 코드로 구현하면 아래와 같이 됩니다.

```python
x = ['a', 'b', 'c', 'd', 'e', 'f']
idxDelete = 3

y = list(range(5))

for itr in range(0, idxDelete):
    y[itr] = x[itr]
    
for itr in range(idxDelete+1, len(x)):
    y[itr-1] = x[itr]
    
x = y
```

삭제 알고리즘에서는 Operation이 몇 번이나 일어날까요? 삽입과 마찬가지로 단계를 나누어 생각해봅시다. 원래 배열의 크기를 N, 삭제할 요소의 인덱스  `idxDelete`  를 `b` 라고 합시다. 그렇다면 그 `0` 부터 `b-1` 까지 참조를 복사하는 데 $b$ 번의 Operation을 수행합니다. 인덱스 `b` 에서는 아무런 Operation없이 건너뛰므로 고려하지 않으면 됩니다. 인덱스 `b+1` 부터 `N` 까지의 참조를 복사하는 데에는 $N - b$ 번의 Operation을 수행합니다. 세 과정에서 수행하는 Operation의 개수를 합하면 삭제 알고리즘에서는 총 $N + 1= b + 1 + (N - b)$ 회의 Operation이 필요함을 알 수 있습니다.



## 문제점

위에서 본 것처럼 배열 속 요소를 탐색하거나 새로운 요소를 삽입, 기존 요소를 삭제하는 절차를 위해서는 최대 N번의 Operation이 필요하다. 배열 내에 수 개의 요소만 있을 경우에는 크게 상관이 없지만 N이 매우 커져 1,000,000개의 요소가 있는 배열이 있다면 하나를 삽입하거나, 삭제하는 데에만도 꽤 오랜 시간이 걸릴 것이다.

삽입을 하는 경우 일정 요소들을 뒤로 이동시키지 않고도 공간을 자동으로 만들어 주는 방법이 있다면 어떨까? 이런 방법은 선형 구조인 배열(Array)에서는 절대 불가능할 것이다. 선형이 아닌 공간에서 이런 방법을 가능케 하는 새로운 데이터 핸들링 방식이 있는데 이를 Linked List라고 한다.