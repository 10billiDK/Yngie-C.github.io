---
layout: post
title: 1. 자료구조 소개
category: Data Structure with C
tag: Data-structure
---





이 카테고리에 올라올 게시물은 주로 [C로 배우는 쉬운 자료구조](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=88315041) (이지영, 한빛아카데미, 2016)를 참고하여 작성하였습니다. 저는 자료구조에 대해 전혀 무지한 상황에서 공부하는 입장이며, 저와 같은 상태에 있으신 분들께서는 포스팅을 참조하시며 같이 공부하시면 좋을 것 같습니다.



## 1) 자료구조의 이해

- 자료구조 : 자료를 효율적으로 **표현** 하고 **저장** 하고 **처리** 할 수 있도록 정리하는 것 (컴퓨터 관련 분야에서 기본적이고도 필수적인 개념)
- 자료구조의 분류 : 표현할 자료의 특성과 주된 사용 방법, 수행하는 연산의 특성, 구현에 필요한 저장 공간 용량과 실행 소요 시간 고려
  - **단순** 구조 : 정수, 실수, 문자, 문자열
  - **선형** 구조 : 순차 리스트, (단순/연결/원형) 연결 리스트, 스택, 큐, 데크
  - **비선형** 구조 : (일반/이진) 트리, (방향/무방향) 그래프
  - **파일** 구조 : 순차 파일, 색인 파일, 직접 파일



<br/>

## 2) 자료의 표현

- 컴퓨터는 1과 0 조합으로 구성된 2진수 코드 사용. 2진수 한 자리 (1 or 0) 을 표현하는 단위를 비트라고 하며, 8비트는 1바이트이다.

- 수치 자료의 표현
  - 10진수의 표현
    - **존(Zone) 형식** 표현 : 10진수 한 자리를 존 형식으로 표현하기 위해 1바이트를 한 단위로 사용. 존 형식을 표현하기 위한 한 단위의 8비트는 상위 4비트의 **존 영역** 과 하위 4비트 **수치 영역** 으로 구성. 존 영역에는 +와 -를 결정하기 위한 정보가, 수치 영역에는 10진수 한 자리를 표현하기 위한 정보가 들어간다. 여러 자리의 10진수를 표현할 때, 가장 마지막 존 영역에만 1100(+), 1101(-)가 들어가고 나머지 존 영역은 1111로 채워진다. 
    - **팩(Pack) 형식** 표현 : 존 형식에서 중복되는 존 영역(최하단 존 영역을 제외한 1111로 채워지는 부분) 때문에 생기는 메모리 낭비를 막기 위한 방법이다. 최하단의 4비트를 제외한 모든 4비트를 수치 영역으로 두고, 최하위 Sign 비트에만 1100(+) 또는 1101(-)를 채워넣는다.
    
  - 2진수의 정수 표현
  
    - n 비트 **부호 절댓값** 형식 : 최상위 1비트는 부호를 나타내는 데에 할당한다. 1(+), 0(-)를 나타낸다. 나머지 비트는 2진수 절댓값을 나타내는 데에 사용한다. 덧셈기와 뺄셈기를 따로 구현해야 한다는 단점을 가지고 있다.
  
    $$
    29 = 10011101_{(2)} \quad -29 = 00011101_{(2)}
    $$
  
    
  
    - **1의 보수** (1' Complement) 형식 : 부호 표현에 따로 비트를 할애하지 않는다. 음수를 표현할 때는 실제 1인 자리수를 0으로, 0인 자리수를 1로 표현한다. 0을 표현함에 있어서 두 표현(+0 : 00000000, -0 : 11111111)이 겹치게 되는 문제가 있다.
  
    $$
    29 = 00011101_{(2)} \quad -29 = 11100010_{(2)} \\
    +0 = 00000000_{(2)} \quad -0 = 11111111_{(2)}
    $$
  
    
  
    - **2의 보수** (1' Complement) 형식 : 부호를 표현할 때 2의 보수를 사용한다. (=1의 보수에 1을 더해준다.) 아래 7 - 4 = 3을 구하는 예시를 보자.
  
    $$
    0111_{(2)} = +7 \\
    1100_{(2)} = -4 \\
    0011_{(2)} = +3
    $$
  
    
  
  - 2진수의 실수 표현
  
    - 고정 소수점 표현 : 소수점이 항상 왼쪽에 있다고 생각하는 방식이다. 아이디어는 간단하지만 표현 범위가 좁다는 단점이 있다.
  
    $$
    0101_{(2)} = 0.0101
    $$
  
    
  
    - **부동 소수점** 표현 : 소수부와 10의 거듭제곱 형식으로 나타낸다. 고정 소수점 형식에 비해 표현 범위가 넓다는 장점이 있다.
  
    $$
    213 = 0.213 \times 10^3
    $$
  
    ![floating point](https://media.geeksforgeeks.org/wp-content/uploads/Single-Precision-IEEE-754-Floating-Point-Standard.jpg)
  
    위의 예에서 0.213은 소수부(Mantissa)로, 3은 지수부(Exponent)로 표현한다. 최상단 1비트에는 부호를 표현하기 위해 할당한다.
  
- 문자 자료의 표현
  - BCD 코드 : Binary-Coded Decimal. 상위 2비트(존 비트)와 하위 4(숫자 비트)로 구성된 6비트를 사용한다. 존 비트는 하위 숫자비트의 값이 숫자인지 문자인지를 나타내주는 값이다. 영어 소문자를 표현할 수 없다는 단점을 가지고 있다.
  
  ![BCD](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F266FD1415659E48D1E1419)
  
  - EBCDIC 코드 : Extended Binary-Coded Decimal Interchange Code. 상위 4비트(존 비트)와 하위 4비트(숫자 비트)로 구성된 8비트를 사용한다. 영어 소문자의 값을 입력할 수 있으나, 영어 이외의 다른 코드는 입력할 수 없다는 단점을 가지고 있다.
  
  ![EBCDIC](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F21416B425659E4BA0F8606)
  
  - **ASCII 코드** : American Standard Code for Information Interchange. 상위 3비트(존 비트)와 하위 4비트(숫자 비트)로 구성된 7비트를 사용한다. 존 비트와 숫자 비트를 조합하여 숫자와 영어 대소문자 뿐만 아니라 특수문자도 나타낼 수 있다. EBCDIC코드보다 표현 범위가 더 넓음에도 비트 수가 더 적어 효율적이다. 또한 남는 1비트(8-7)를 통신 과정에서 데이터의 변조, 손상을 확인할 수 있는 [패리티 비트]([https://ko.wikipedia.org/wiki/%ED%8C%A8%EB%A6%AC%ED%8B%B0_%EB%B9%84%ED%8A%B8](https://ko.wikipedia.org/wiki/패리티_비트))로 활용할 수 있다.
  
  ![ASCII1](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F243F683D5659E4F211800F)
  
  ![ASCII2](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2230FA3D5659E5BA1515AB)
  
  - **유니코드** (Unicode) : 위 표현법들은 영어 이외의 언어를 표현할 수 없다는 단점을 가지고 있다. [유니코드](https://www.unicode.org/)는 이런 문제를 해결하기 위한 표기법이다. 유니코드는 총 16비트로 구성되어 있으며 다양한 언어를 표현할 수 있다.
  
- 논리 자료의 표현 : 논리값을 표현하기 위한 자료 형식이다. 프로그램은 0을 제외하고는 모두 참으로 인식한다.

$$
00000001_{(2)} = \text{True} \quad 00000000 = \text{False} \\
11111111_{(2)} = \text{True} \quad 00000000 = \text{False} \\
01101001_{(2)} = \text{True} \quad 00000000 = \text{False} 
$$



- 포인터 자료의 표현 : **포인터** (Pointer) 자료는 메모리 주소를 표현하기 위한 자료 형식이다. 자료를 저장하고 있는 변수나 특정 위치의 메모리 주소를 저장한다. 포인터 자료를 사용하면 복잡한 자료구조 연산을 메모리에서의 주소 연산만으로 처리할 수 있다.

- 문자열 자료의 표현 : 문자열 자료란 한 글자가 아닌 여러 글자로 이루어진 문자 그룹을 하나의 자료로 취급하여 메모리에 연속적으로 저장하는 자료 형식이다. 문자열 하나는 부분 문자열을 여러 개 포함할 수 있다. 문자열 표현에는 총 3가지 방법이 있다.

  1. 부분 문자열 사이에 구분자(;) 사용
  2. 가장 긴 문자열 길이에 맞추어 고정 길이로 저장
  3. 부분 문자열을 연속 저장한 후 포인터 사용

  아래는 [Computer Data Struct String]을 각 방법으로 저장한 예시다.

![String](https://t1.daumcdn.net/cfile/tistory/992AE6495AEFF03A2E)

첫 번째 방법은 메모리 할당량이 적지만 특정 문자열을 탐색하는 데 걸리는 시간이 길다. 두 번째 방법은 특정 문자열을 빠르게 찾을 수는 있지만, 공간을 많이 낭비(검은색)하게 된다는 단점이 있다. 마지막 방법은 메모리 할당량이 가장 적고, 특정 문자열을 찾을 때에도 **메모리 연산** 을 이용하여 빠르게 찾아낼 수 있다는 장점이 있다.

<br/>

## 3) 자료의 추상화



<br/>

## 4) 알고리즘의 이해



<br/>

## 5) 알고리즘의 표현 방법



<br/>

## 6) 알고리즘의 성능 분석



<br/>