---
title: 해싱, 해시함수, 해시테이블
category: Data structure&Algorithm
tag: Data structure
---

이번 글에서는 **해싱(hashing)**에 대해 살펴보도록 하겠습니다. 이 글은 고려대 김선욱 교수님 강의와 위키피디아, 그리고 [이곳](http://www.geeksforgeeks.org/hashing-set-3-open-addressing/)을 참고해 정리하였음을 먼저 밝힙니다. 그럼 시작하겠습니다.





## concepts

**해시함수(hash function)**란 데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수입니다. 이 때 매핑 전 원래 데이터의 값을 **키(key)**, 매핑 후 데이터의 값을 **해시값(hash value)**, 매핑하는 과정 자체를 **해싱(hashing)**라고 합니다. 

대개 해시함수는 해쉬값의 개수보다 많은 키값을 해쉬값으로 변환하기 때문에 해시함수가 서로 다른 두 개의 키에 대해 동일한 해시값을 내는 **해시충돌(collision)**이 발생하게 됩니다. 아래 그림은 이름-전화번호부를 매핑하기 위한 해시함수를 개념적으로 나타냈습니다. 예시의 해시함수는 'John Smith'와 'Sandra Dee'를 모두 '02'로 매핑해 해시충돌을 일으키고 있습니다.



<a href="https://imgur.com/NnEBDcX"><img src="https://i.imgur.com/NnEBDcX.png" title="source: imgur.com" /></a>



그럼에도 해시를 쓰는 이유는 적은 리소스로 많은 데이터를 효율적으로 관리하기 위해서입니다. 예컨대 해시함수로 하드디스크나 클라우드에 존재하는 무한에 가까운 데이터(키)들을 유한한 개수의 해시값으로 매핑함으로써 작은 크기의 캐쉬 메모리로도 프로세스를 관리할 수 있게 됩니다. 

색인(index)에 해시값을 사용함으로써 모든 데이터를 살피지 않아도 검색과 삽입/삭제를 빠르게 수행할 수 있습니다. 위 그림의 경우 해시함수에 'Lisa Smith'를 입력하면 02라는 색인이 생성됩니다. 해시함수는 언제나 동일한 해시값을 리턴하고, 계산이 간단한 함수(대개 상수시간)로 작동하기 때문에 데이터를 액세스할 때 원하는 데이터를 찾는 비용을 줄일 수 있습니다.

해시는 보안 분야에서도 널리 사용된다고 합니다. 키와 해시값 사이에 직접적인 연관이 없기 때문에 해시값만 가지고는 키를 온전히 복원하기 어렵기 때문입니다.

현재까지 개발된 거의 모든 해시함수는 해시충돌을 일으키는 것으로 확인됐다고 합니다. 물론 해시충돌 자체를 줄이는 것도 의미가 있겠습니다만, 중요한 것은 해시충돌이 해시값 전체에 걸쳐 균등하게 발생하게끔 하는 것입니다. 

예컨대 위 그림에서 모든 키가 02라는 동일한 해시값으로 매핑이 될 경우 데이터를 액세스할 때 비효율성이 커지고, 보안이 취약(서로 다른 키인데도 동일한 해시값)해져 굳이 해시를 도입해 데이터를 관리할 이유가 없어집니다. 





## 해시테이블

해시함수를 사용하여 키를 해시값으로 매핑하고, 이 해시값을 색인(index)으로 하여 데이터의 값(value)을 키와 함께 저장하는 자료구조를 **해시테이블(hash table)**이라고 합니다. 이 때 데이터가 저장되는 곳을 버킷(bucket) 또는 슬롯(slot)이라고 합니다. 다음 그림과 같습니다.



<a href="https://imgur.com/EMW1YZP"><img src="https://i.imgur.com/EMW1YZP.png" title="source: imgur.com" /></a>



키의 전체 개수와 동일한 크기의 버킷을 가진 해시테이블을 Direct-address table이라고 합니다. 다음 그림과 같습니다.



<a href="https://imgur.com/ySs5La4"><img src="https://i.imgur.com/ySs5La4.png" width="400px" title="source: imgur.com" /></a>



Direct-address table의 장점은 키 개수와 해시테이블 크기가 동일하기 때문에 해시충돌 문제가 발생하지 않는다는 겁니다. 하지만 실제 사용하는 키(actucal key)보다 전체 키(unverse of key)보다 훨씬 많은 경우 사용하지 않는 키들을 위한 공간까지 마련해야 하는 탓에 메모리 효율성이 크게 떨어집니다. 위 그림처럼 1, 9, 4, 0, 7, 6을 위한 버킷은 굳이 만들어놓을 이유가 없습니다. 

보통의 경우 Direct-address table보다는 해시테이블 크기($m$)가 실제 사용하는 키 개수($n$)보다 적은 해시테이블을 운용합니다. 다뤄야할 데이터가 정말 많고, 메모리 등 리소스 문제도 생기기 때문입니다. 이 때 $n/m$을 **load factor**($α$)라고 합니다. 해시테이블의 한 버킷에 평균 몇 개의 키가 매핑되는가를 나타내는 지표입니다. Direct-address table의 load factor는 1 이하이며, 1보다 큰 보통의 경우 해시충돌 문제가 발생합니다. 

해시충돌 문제를 해결하기 위해 다양한 기법들이 고안됐습니다. chining과 open addressing은 자료를 저장하는 구조를 개선하는 방안입니다. 해시함수를 개선하는 접근도 있습니다. 차례대로 살펴보겠습니다.





## chaining

해시충돌 문제를 해결하기 위한 간단한 아이디어 가운데 하나는 한 버킷당 들어갈 수 있는 엔트리의 수에 제한을 두지 않음으로써 모든 자료를 해시테이블에 담는 것입니다. 해당 버킷에 데이터가 이미 있다면 체인처럼 노드를 추가하여 다음 노드를 가리키는 방식으로 구현(연결리스트)하기 때문에 체인이라는 말이 붙은 것 같습니다. 유연하다는 장점을 가지나 메모리 문제를 야기할 수 있습니다. 아래 그림과 같습니다.



<a href="https://imgur.com/7PTT8dT"><img src="https://i.imgur.com/7PTT8dT.png" title="source: imgur.com" /></a>



위 예시 그림의 해시함수는 'John Smith'와 'Sandra Dee'를 같은 해시값(152)으로 매핑하고 있습니다. 이 경우 해당 해시값에 대응하는 동일한 버킷에 두 개 데이터를 저장해 둡니다. 데이터를 위 그림처럼 연결리스트로 저장해 둘 경우 최근 데이터는 연결리스트의 *head*에 추가합니다(이 경우 $O(1)$, *tail*에 저장할 경우 $O(n)$이 됨, 자세한 내용은 [이곳](https://ratsgo.github.io/data%20structure&algorithm/2017/09/30/list/) 참고)



### 삽입, 탐색, 삭제 연산과 계산복잡성

chaining 방식의 계산복잡성을 따져보겠습니다. 삽입(insertion), 탐색(search), 삭제(delete) 세 가지가 있습니다. 본격적인 분석에 앞서 가정을 하나 하겠습니다. 해시테이블의 크기가 $m$, 실제 사용하는 키 개수가 $n$, 해시함수가 키들을 모든 버킷에 균등하게 할당한다고 가정하면, 버킷 하나당 $n/m=α$개의 키들이 존재할 것입니다. 예컨대 위 그림 예시에서 2550개의 키에 해당하는 데이터를 저장한다면 버킷 하나당 10개 데이터가 있다는 얘기입니다.

삽입의 계산복잡성입니다. 예컨대 위 예시그림의 해시함수가 254로 매핑하는 'Mark Zuckerberg'의 전화번호를 새로 추가한다고 칩시다. 'Mark Zuckerberg'라는 키를 해시값 254로 매핑하는 데 $O(1)$이 듭니다. 해당 해시값에 해당하는 연결리스트의 *head*에 이를 추가하는 데 $O(1)$이 듭니다. 따라서 삽입의 계산복잡성은 둘을 합친 $O(1)$입니다.

마지막으로 탐색을 살펴보겠습니다. 두 가지로 나눠서 생각해 보겠습니다. 

쿼리 키값에 해당하는 데이터가 해시테이블에 존재하지 않는 경우(unsuccessful search)입니다. 예컨대 위 예시그림의 해시함수가 152로 매핑하는 'Steve Jobs'의 전화번호를 탐색한다고 가정해 봅시다. 이 경우 키를 해시값으로 바꾸고, 해당 해시값에 해당하는 버킷의 요소들 $α$개를 모두 탐색해봐야 할 겁니다. 따라서 unsuccessful search의 계산복잡성은 $O(1+α)$가 됩니다.

이번엔 쿼리 키값에 해당하는 데이터가 해시테이블에 존재하는 경우(successful search)입니다. 예컨대 'John Smith'의 전화번호를 위와 같은 해시테이블에서 탐색한다고 가정해 봅시다. 'Sandra Dee'를 해시값(152)으로 바꾸고 버킷 요소들 가운데 'Sandra Dee'에 해당하는 데이터가 있는지 탐색해봐야 할 겁니다. 

최고 좋은 케이스라면 해당 버킷 *head*에 찾고자 하는 값이 있는 경우일 테고, 최악의 경우 해당 버킷의 *tail*에 값이 있는 경우일 겁니다(1번 비교). 데이터가 해시테이블에 존재한다고 가정했으므로 $α$개 가운데 하나는 반드시 찾고자 하는 값입니다. $α-1$개를 비교했는데도 원하는 값을 찾지 못했다면 마지막 *tail*값은 따져볼 필요도 없이 찾고자 하는 값이 됩니다. 최악의 경우는 $α-1$개를 unsuccessful search해서 해당 데이터를 *head*에 삽입한 것과 본질적으로 비슷하다는 이야기입니다. 따라서 successful search의 계산복잡성 또한 $O(1+α)$가 됩니다.

삭제의 계산복잡성은 탐색과 본질적으로 비슷합니다. 우선 쿼리 키값을 해시값으로 매핑하고($O(1)$), 해당 버킷 내에 키값에 해당하는 데이터가 있는지 탐색($O(α)$)해야 하기 때문입니다. 물론 탐색 연산과 비교해 삭제에 드는 계산도 추가적으로 필요하나, 연결리스트로 해시테이블을 구현할 경우 삭제 연산의 계산복잡성은 $O(1)$이므로 무시할 만한 수준입니다. 

요컨대 chaning에서 삽입을 제외한, 탐색/삭제의 계산복잡성은 버킷당 요소 개수의 평균 $α$가 좌지우지하는 구조입니다. Direct-address table처럼 $α$가 1일 경우 chaining의 삽입, 탐색, 삭제 계산복잡성은 모두 $O(1)$이 됩니다.





## open addressing

open addressing은 chaining과 달리 한 버킷당 들어갈 수 있는 엔트리가 하나뿐인 해시테이블입니다. 메모리 문제가 발생하지 않으나 해시충돌이 생길 수 있습니다. 예컨대 해시함수를 '키값을 7로 나눈 나머지'로 정의했다고 칩시다. 그리고 나서 키 50, 700, 76, 85, 92, 73, 101순으로 데이터를 저장한다고 가정해 봅시다. 다음 그림과 같습니다.



<a href="https://imgur.com/IM4FA2h"><img src="https://i.imgur.com/IM4FA2h.png" title="source: imgur.com" /></a>



위 예시에서 주목할 부분은 85부터입니다. 85를 7로 나눈 나머지는 1입니다. 그런데 해시값 1에 해당하는 버킷에 이미 50이 있으므로, 다음 버킷(2)에 저장해 둡니다. 92를 7로 나눈 나머지 역시 1입니다. 그런데 해시값 1에 해당하는 버킷에 이미 50이 있고, 그 다음 해시값 2 버킷에 85가 있으므로, 92를 3번 버킷에 저장합니다. 73, 101 역시 자신의 버킷에는 이미 주인이 있으므로 빈 버킷에 할당합니다.



### 삽입과 탐색 연산

open addressing의 삽입 연산을 구현할 때는 비어있다(empty)고 전제하고, 탐색 연산을 구현할 땐 모든 버킷이 꽉 차있다(full)고 전제해야 합니다. 예컨대 해시함수가 '키값을 8로 나눈 나머지'이고 10, 18, 26 순으로 해시테이블에 삽입한다고 가정해 보겠습니다. 

세 숫자 가운데 첫번째 입력값 10을 제외한 18, 26은 원래 버킷(2) 말고 각각 다음(3), 다음다음(4) 버킷에 저장하는 것이 open addressing의 방식입니다. 그런데 모든 버킷이 비어있다고 전제하지 않고 반복문을 구현하게 되면, 알고리즘은 18과 26의 삽입을 포기하게 될 수 있습니다.

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |      |  10  |  18  |  26  |      |      |      |      |

위 표에서 18을 삭제해 보겠습니다. 18의 해시값은 2인데 여기엔 10이 저장돼 있으므로 스킵하고, 그 다음 버킷(3)을 탐색해 봅니다. 18이 여기에 있군요. 지웁니다. 다음과 같습니다.

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |      |  10  |      |  26  |      |      |      |      |

위 표에서 26을 탐색해 보겠습니다. 26의 해시값은 2인데 여기엔 10이 저장돼 있으므로 스킵하고, 그 다음 버킷(3)을 탐색해 봅니다. 그런데 비어 있습니다. 모든 버킷이 꽉 차있다고 전제하지 않고 반복문을 구현하게 되면 알고리즘은 탐색을 중도에 포기하게 된다는 얘기입니다.



### probing

open addressing은 그 구조상 해시충돌 문제가 발생할 수 있습니다. 앞선 예시에서 살펴봤듯 특정 해시값에 키가 몰리게 되면 open addressing의 효율성이 크게 떨어집니다. 해시충돌은 탐사(probing) 방식으로 해결할 수 있습니다.



### 계산복잡성

open addressing의 계산복잡성은 chaining과 본질적으로 동일합니다.





## 해시함수

좋은 해시함수의 조건은 $1/m$을 만족하는 것입니다.



### division method



### multiplication method



### universal hasing









